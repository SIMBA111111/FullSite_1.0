<p>Асинхронное программирование может быт куда сложнее синхронного в написании, понимании и отладке.</p><p>Сравним подходы к написанию кода и выясним по конкретным цифрам, стоит ли игра свеч.</p><p>Для измерения скорости работы веб-приложений я буду использовать веб-сервис Artillery. Он позволяет проводить нагрузочное тестирование легко и наглядно. Установить его легко, одной командой</p><p>Такой конфиг я буду использовать для тестирования:</p><div class="code"><p>config:</p><p>  target: 'http://127.0.0.1:8080'</p><p>  phases:</p><p>    - duration: 60</p><p>      arrivalRate: 1</p><p>      rampTo: 120</p><p>  plugins:</p><p>    ensure: {}</p><p>    apdex: {}</p><p>    metrics-by-endpoint: {}</p><p>  apdex:</p><p>    threshold: 100</p><p>scenarios:</p><p>  - flow:</p><p>      - loop:</p><p>          - get:</p><p>              url: '/test/sync_get_all_comments'</p><p>        count: 1</p></div><p>Параметр <strong>duration</strong> означает, что тестирование будет длиться 60 секунд, параметр <strong>arrivalRate</strong> означает, что будет создать один виртуальный юзер, который выполнит запрос к моему API, а <strong>rampTo</strong> означает, что в течение тестирования количество виртуальных юзеров будет расти постепенно так, чтобы до конца процесса было создано 120 виртуальных юзеров. </p><p>Принцип же работы тестирования в ежесекундном увеличении количества виртуальных юзеров, отправляющих запросы на указанный url <strong>'/test/sync_get_all_comments'</strong>. Параметр <strong>count: 1</strong> означает, что каждый виртуальный юзер выполнит 1 запрос и будет уничтожен. В следующую секунду будет создано другое количество юзеров, отправляющих запрос.</p><p>Начнём с синхронного кода, для которого я написал синхронную вьюху:</p><div class="code"><p>class SyncCommentsView(View):<br />    <br />     def get(self, request, *args, **kwargs):<br />        cr = services.get_all_comments()<br />        response_data = [{'id': comment.id, 'title': comment.text} for comment in cr]<br />        return JsonResponse(response_data, safe=False)</p></div><p>метод <strong>get_all_comments() </strong>из файла services:</p><div class="code"><p>def get_all_comments():<br />    return CommentsModel.objects.filter(id__lte=100)</p></div><p>Я буду получать первые 100 записей из БД.</p><p>Вывод этого запроса выглядит так:</p><p><img src="http://127.0.0.1:80/static/articles/1_sinhronnyj_dzhango_vs_ainhronnyj_dzhango/1.png" /></p><p>Я просто сгенерировал случайные строки и добавил их в БД.</p><p>Сами модели выглядят так:</p><div class="code"><p>UserModel = get_user_model()</p><p>class ArticleAuthorModel(models.Model):<br />    author = models.ForeignKey(UserModel, models.CASCADE)<br />    article = models.ForeignKey(&quot;ArticleModel&quot;, models.CASCADE)<br /><br /><br />class ArticleModel(models.Model):<br />    title = models.CharField(max_length=80)<br />    email = models.CharField(max_length=50)<br />    author = models.ManyToManyField(UserModel, &quot;articles&quot;, through=ArticleAuthorModel)<br /><br />    class Meta:<br />        db_table = &quot;ArticleModel&quot;<br /><br /><br />class CommentsModel(models.Model):<br />    text = models.TextField()<br />    article = models.ForeignKey(ArticleModel, models.CASCADE, &quot;comments&quot;)<br />    author = models.ForeignKey(UserModel, models.CASCADE, &quot;comments&quot;)<br /><br />    class Meta:<br />        db_table = &quot;CommentsModel&quot;</p></div><p>Запускать приложения я буду в докере с PostgreSQL в качестве БД. Dockerfile выглядит следующим образом:</p><div class="code"><p>FROM python:3.12<br /><br />WORKDIR /code<br /><br />COPY ./requirements.txt /code/requirements.txt<br /><br />RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt<br /><br />COPY . /code</p></div><p>Файл docker-compose.yaml выглядит так:</p><div class="code"><p>version: &quot;3.0&quot;<br /><br />services:<br />  back:<br />    build: .<br />    container_name: &quot;backend&quot;<br />    command: sh -c &quot;python manage.py makemigrations &amp;&amp; python manage.py migrate &amp;&amp; gunicorn config.wsgi:application --bind 0.0.0.0:8080&quot;<br />    ports:<br />     - &quot;8080:8080&quot;<br />    restart: unless-stopped<br />    depends_on:<br />      - db<br /><br />  db:<br />    image: postgres:16.3-alpine3.20<br />    container_name: &quot;db&quot;<br />    environment:<br />      POSTGRES_USER: admin<br />      POSTGRES_PASSWORD: admin<br />      POSTGRES_DB: admin<br />    volumes:<br />      - db_data:/var/lib/postgresql/data<br />    ports:<br />      - &quot;5432:5432&quot;<br />    restart: unless-stopped<br /><br /><br />volumes:<br />  db_data:</p></div><p>Важно отметить, что в качестве сервера приложений я использую не встроенный тестовый сервер джанги, а gunicorn. Разработчики джанги сами настоятельно советуют не использовать их сервер в чем угодно кроме отладки и разработки. Еще важно отметить, что gunicorn не запустится на виндусе, т.к. он включает в себя модуль <strong>fctnl</strong>, не поддерживающий винду.</p><p>Командой </p><div class="code"><p>artillery run --name sync_django_1_worker C:\Users\na2ar\Desktop\asciiart-load-test.yml --record --key &lt;сюда вставить свой ключ&gt;</p></div><p>Запускаю тестирование. Через 72 секунды получаю результат:</p><p><img src="http://127.0.0.1:80/static/articles/1_sinhronnyj_dzhango_vs_ainhronnyj_dzhango/2.png" /></p><p>Видно, что со временем количество запросов, юзеров и время ответа росли. Самый важный на мой взгляд этап начался в точке, обозначенной второй красной стрелкой. Здесь выше нуля стал показатель vusers.failed. Он означает, что юзер создался, отправил запрос, и, не получив ответа, умер. Т.е. произошла ошибка и ответ не вернулся совсем. До него все запросы обрабатывались с ответом 200, но с возрастающей до 9.8 сек на пике скоростью. Сверху видно, что успешно выполнились лишь 34.68% юзеров.</p><p>Далее пробуем синхронный подход. Меняю в конфиге Artillery параметр <strong>url </strong>на<strong> </strong>url:<strong> '/test/async_get_all_comments'</strong></p><p>Вью выглядит так:</p><div class="code"><p>class CommentsView(View):<br />    <br />    async def get(self, request, *args, **kwargs):<br />        cr = await services.async_get_all_comments()<br />        response_data = [{'id': comment.id, 'title': comment.text} async for comment in cr]<br />        return JsonResponse(response_data, safe=False)</p></div><p>функция так:</p><div class="code"><p>async def async_get_all_comments():<br />    return await sync_to_async(get_all_comments)()</p></div><p>Файл docker-compose.yaml выглядит так:</p><div class="code"><p>version: &quot;3.0&quot;<br /><br />services:<br />  back:<br />    build: .<br />    container_name: &quot;backend&quot;<em><br />    </em>command: sh -c &quot;python manage.py makemigrations &amp;&amp;<br />                    python manage.py migrate &amp;&amp;<br />                    gunicorn -w 1 -k uvicorn.workers.UvicornWorker config.asgi:application --bind 0.0.0.0:8080&quot;<br />    ports:<br />     - &quot;8080:8080&quot;<br />    restart: unless-stopped<br />    depends_on:<br />      - db<br /><br />  db:<br />    image: postgres:16.3-alpine3.20<br />    container_name: &quot;db&quot;<br />    environment:<br />      POSTGRES_USER: admin<br />      POSTGRES_PASSWORD: admin<br />      POSTGRES_DB: admin<br />    volumes:<br />      - db_data:/var/lib/postgresql/data<br />    ports:<br />      - &quot;5432:5432&quot;<br />    restart: unless-stopped<br /><br /><br />volumes:<br />  db_data:</p></div><p>Я изменил команду запуска сервера приложений:</p><div class="code"><p>gunicorn -w 1 -k uvicorn.workers.UvicornWorker config.asgi:application --bind 0.0.0.0:8080</p></div><p>теперь гуникорн запускается с одним асинхронным воркером и использует спецификацию asgi вместо wsgi. Для установки сервера приложений uvicorn, воркеры которого используются для асинхронного выполнения кода, надо установить его командой:</p><div class="code"><p>pip install uvicorn</p></div><p>Далее запускаю тестирование всё той же командой и получаю результат:</p><p><img src="http://127.0.0.1:80/static/articles/1_sinhronnyj_dzhango_vs_ainhronnyj_dzhango/3.png" /></p><p>Видно, что количество отправленных запросов стало меньше. На пике – 108 запросов в секунду против 112 в синхронной версси. К тому же, количество убитых юзеров было не равно нуля практически весь период тестирования. Пик времени ответа пришелся на 40 секунду и дальше упал до нуля, в то время как показатель смертей юзеров (ответы с ошибкой) достигли пика. Еще один факт – во время тестирования в логах бекенда я получил много таких сообщений:</p><p><img src="http://127.0.0.1:80/static/articles/1_sinhronnyj_dzhango_vs_ainhronnyj_dzhango/4.png" /></p><p>База данных просто не смогла справиться с количеством запросов и возвращала ошибки. Это учитывая, что я использовал psycopg3, который должен поддерживать асинхронность.</p><p>Таким образом, можно сделать вывод, что асинхронный код быстрее принимал входящие запросы и отправлял запрос в БД, чем синхронный. Однако база оказалась не в состоянии работать асинхронно или как угодно по-другому параллельно обрабатывать запросы. Поэтому выгоду от использования асинхронности можно увидеть в запросах, не использующих БД. В новых версиях джанго было совершенно много шагов в сторону асинхронности, но на фоне FastAPI он до сих пор отстаёт.</p>