<p>В прошлой статье я сравнил синхронный и асинхронный Django. Теперь проверим FastAPI</p><p>Для измерения скорости работы веб-приложений я всё также использую веб-сервис Artillery. Он позволяет проводить нагрузочное тестирование легко и наглядно. Установить его легко, одной командой</p><p>Конфиг для тестирования я использую тот же, изменив лишь порт и url:</p><div class="code"><p>config:</p><p>  target: 'http://127.0.0.1:80'</p><p>  phases:</p><p>    - duration: 60</p><p>      arrivalRate: 1</p><p>      rampTo: 120</p><p>  plugins:</p><p>    ensure: {}</p><p>    apdex: {}</p><p>    metrics-by-endpoint: {}</p><p>  apdex:</p><p>    threshold: 100</p><p>scenarios:</p><p>  - flow:</p><p>      - loop:</p><p>          - get:</p><p>              url: '/sync_get_all_comments'</p><p>        count: 1</p></div><p>Параметр <strong>duration</strong> означает, что тестирование будет длиться 60 секунд, параметр <strong>arrivalRate</strong> означает, что будет создать один виртуальный юзер, который выполнит запрос к моему API, а <strong>rampTo</strong> означает, что в течение тестирования количество виртуальных юзеров будет расти постепенно так, чтобы до конца процесса было создано 120 виртуальных юзеров. </p><p>Принцип же работы тестирования в ежесекундном увеличении количества виртуальных юзеров, отправляющих запросы на указанный url <strong>'/sync_get_all_comments'</strong>. Параметр <strong>count: 1</strong> означает, что каждый виртуальный юзер выполнит 1 запрос и будет уничтожен. В следующую секунду будет создано другое количество юзеров, отправляющих запрос.</p><p>Начнём с синхронного кода, для которого я написал синхронную вьюху:</p><div class="code"><p>@app.get(&quot;/sync_get_all_comments&quot;)<br />def async_get_all_comments(db: Session = Depends(get_db)):<br />    result = db.execute(<br />        select(CommentsModel)<br />        .filter(<br />            CommentsModel.id &lt;= 100<br />        )<br />    )<br />    return result.scalars().all()</p></div><p>Я буду получать первые 100 записей из БД.</p><p>Вывод этого запроса выглядит так:</p><p><img src="http://127.0.0.1:80/static/articles/3_sinhronnyj_FastAPI_vs_asinhronnyj_FastAPI/1.png" /></p><p>Я просто сгенерировал случайные строки и добавил их в БД.</p><p>Сами модели выглядят так:</p><div class="code"><p>from sqlalchemy import Integer, String, ForeignKey<br />from sqlalchemy.orm import Mapped, mapped_column, relationship<br />from database import Base<br /><br /><br />class UserModel(Base):<br />    __tablename__ = &quot;user&quot;<br /><br />    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)<br />    username: Mapped[str] = mapped_column(String, unique=True)  # добавлен unique=True для уникальности<br /><br />    # Define relationship if needed<br />    comments: Mapped[list[&quot;CommentsModel&quot;]] = relationship(&quot;CommentsModel&quot;, back_populates=&quot;author&quot;)<br /><br /><br />class ArticleModel(Base):<br />    __tablename__ = 'article'<br /><br />    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)<br />    title: Mapped[str] = mapped_column(String, unique=True)  # добавлен unique=True для уникальности<br /><br />    # Define relationship if needed<br />    comments: Mapped[list[&quot;CommentsModel&quot;]] = relationship(&quot;CommentsModel&quot;, back_populates=&quot;article&quot;)<br /><br /><br />class CommentsModel(Base):<br />    __tablename__ = 'comment'<br /><br />    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)<br />    text: Mapped[str] = mapped_column(String)<br />    author_id: Mapped[int] = mapped_column(ForeignKey(&quot;user.id&quot;))<br />    article_id: Mapped[int] = mapped_column(ForeignKey(&quot;article.id&quot;))<br /><br />    # Define relationships<br />    author: Mapped[&quot;UserModel&quot;] = relationship(&quot;UserModel&quot;, back_populates=&quot;comments&quot;)<br />    article: Mapped[&quot;ArticleModel&quot;] = relationship(&quot;ArticleModel&quot;, back_populates=&quot;comments&quot;)</p></div><p>Файл database выглядит так:</p><div class="code"><p>from sqlalchemy import create_engine<br />from sqlalchemy.orm import DeclarativeBase, sessionmaker<br /><br /><br />SQLALCHEMY_DATABASE_URL = &quot;postgresql://admin:admin@db:5432/admin&quot;<br />engine = create_engine(<br />    SQLALCHEMY_DATABASE_URL<br />)<br /><br />sync_session = sessionmaker(bind=engine, expire_on_commit=False)<br /><br /><br />class Base(DeclarativeBase):<br />    pass</p></div><p>Файл с зависимостями:</p><div class="code"><p>from database import sync_session<br /><br /><br />def get_db():<br />    db = sync_session()<br />    try:<br />        yield db<br />    finally:<br />        db.close()</p></div><p>Запускать приложения я буду в докере с PostgreSQL в качестве БД. Dockerfile выглядит следующим образом:</p><div class="code"><p>FROM python:3.12<br /><br />WORKDIR /code<br /><br />COPY ./requirements.txt /code/requirements.txt<br /><br />RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt<br /><br />COPY . /code</p></div><p>Файл docker-compose.yaml выглядит так:</p><div class="code"><p>version: &quot;3.0&quot;<br /><br />services:<br />  back:<br />    build: .<br />    container_name: &quot;backend&quot;<br />    ports:<br />     - &quot;80:80&quot;<br />    restart: unless-stopped<br />    command: sh -c &quot;gunicorn -w 1 -k uvicorn.workers.UvicornWorker main:app --bind 0.0.0.0:80&quot;<em><br /><br />  </em>db:<br />    image: postgres:16.3-alpine3.20<br />    container_name: db<br />    environment:<br />      POSTGRES_USER: admin<br />      POSTGRES_PASSWORD: admin<br />      POSTGRES_DB: admin<br />    volumes:<br />      - db_data:/var/lib/postgresql/data<br />    ports:<br />      - &quot;5432:5432&quot;<br />    restart: unless-stopped<br />    depends_on:<br />      - back<br />volumes:<br />  db_data:</p></div><p>При тестировании синхронного django, я не использовал для gunicorn асинхронный uvicorn воркер, но FastAPI не поддерживает синхронные воркеры, которые gunicorn использует по умолчанию. Также в прошлой статье я говорил я писал, что gunicorn включает в себя модуль <strong>fctnl</strong>, который не поддерживает винду, из-за чего придется запускать приложение в докере.</p><p>С помощью команды:</p><div class="code"><p>artillery run --name sync_fastapi_1_worker C:\Users\na2ar\Desktop\asciiart-load-test.yml --record --key &lt;сюда вставить свой ключ&gt;</p></div><p>Запускаю тестирование. Через 73 секунды получаю результат:</p><p><img src="http://127.0.0.1:80/static/articles/3_sinhronnyj_FastAPI_vs_asinhronnyj_FastAPI/2.png" /></p><p>Видно, что со временем количество запросов, юзеров и время ответа росли. Самый важный на мой взгляд этап начался в точке, обозначенной красной стрелкой. Здесь выше нуля стал показатель vusers.failed. Он означает, что юзер создался, отправил запрос, и, не получив ответа, умер. Т.е. произошла ошибка и ответ не вернулся совсем. До него все запросы обрабатывались с ответом 200, но с возрастающей до 3.2 сек на пике скоростью. Сверху видно, что успешно выполнились 41.02% юзеров.</p><p>Далее пробуем асинхронный подход. Меняю в конфиге Artillery параметр <strong>url </strong>на<strong> </strong>url:<strong> '/async_get_all_comments'</strong></p><p>Вью выглядит так:</p><div class="code"><p>@app.get(&quot;/async_get_all_comments&quot;)<br />async def async_get_all_comments(db: AsyncSession = Depends(get_db)):<br />    result = await db.execute(<br />        select(CommentsModel)<br />        .filter(<br />            CommentsModel.id &lt; 100<br />        )<br />    )<br />    return result.scalars().all()</p></div><p>В файле <strong>database</strong> я изменил диалект бд на <strong>asyncpg</strong>. Для создания сессий использую <strong>async_sessionmaker</strong>:</p><p>!@#$<br />from sqlalchemy.orm import DeclarativeBase<br />from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncAttrs<br /><br /><br />SQLALCHEMY_DATABASE_URL = &quot;postgresql+asyncpg://admin:admin@db:5432/admin&quot;<br />engine = create_async_engine(<br />    SQLALCHEMY_DATABASE_URL<br />), expire_on_commit=False)<br /><br /><br />class Base(AsyncAttrs, DeclarativeBase):<br />    pass</p><div class="code"><p>Файл с зависимостями такой:</p></div><p>from database import async_session<br /><br /><br />async def get_db():<br />    async with async_session() as session:<br />        yield session</p><div class="code"><p>Файл docker-compose.yaml выглядит также</p><p>Далее запускаю тестирование всё той же командой и получаю результат:</p><p><img src="http://127.0.0.1:80/static/articles/3_sinhronnyj_FastAPI_vs_asinhronnyj_FastAPI/3.png" /></p><p>Результат асинхронного кода превзошел синхронный наглядно. Если синхрон смог достичь успешной обработки лишь 59 запросов в секунду до начала смерти юзеров (ответов с ошибкой), то асинхрон достиг 97 успешно обработанных запросов в секунду. То как росло время ответа (голубая линия) по сравнению в синхронным кодом – занавес! Асинхронный код держал время ответа ниже секунды (кроме одной точки) практически до конца. Синхронный же сдался через 20 секунд и заставил приложение грузиться столько, сколько человек не будет ждать и закроет его</p><p>Вывод напрашивается сам собой – асинхронность в контексте FastAPI даёт очевидное преимущество в производительности</p><p>Сравнивая результаты с джанго – выбор очевиден. Однако в следующей статье я сравню лучший конфиг Django против лучшей сборки FastAPI</p>