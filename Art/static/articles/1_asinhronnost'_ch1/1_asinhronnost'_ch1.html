<p>Единственное назначение асинхронности – заполнение задержек между выполнением инструкций.</p><p>Реально параллельно код в питоне выполняется только при ресурсозатратном мультипроцессинге (библиотека multiprocessing), запуская отдельные процессы. Асинхронность и многопоточность же лишь заполняют время простоя. </p><p>Синхронный код выполняет строки кода друг за другом, даже если выполняется ожидание данных. Примеры:</p><div class="code"><p>x = 5<br />y = 10</p><p>y -= x<br />res1 = requests.get(&quot;https://www.youtube.com&quot;)<br />res2 = requests.get(&quot;https://vk.com/feed&quot;)</p></div><p>Каждая следующая строчка не будет выполняться до момента, пока не выполнена предыдущая. Это значит, что строка <strong>res2 = requests.get(&quot;https://vk.com/feed&quot;)</strong> не выполнится, пока полностью не отработает строка <strong>res1 = requests.get(&quot;https://www.youtube.com&quot;)</strong>, в которой выполняется запрос к интернет ресурсу. Это операция ввода. Она требует времени, пока запрос дойдёт до сервера, соберутся нужные данные, и вернётся ответ. Пока все это происходит, наша программа будет просто стоять на месте, чтобы получить результат и записать его в переменную <strong>res1</strong>. Мощности компьютера в этот момент не используются, т.к. не происходит никаких вычислений. Примерно так это выглядит:</p><p><img src="http://127.0.0.1:80/static/articles/1_asinhronnost'_ch1/1.png" /></p><p>А если результат придётся ждать долго? То программа совсем встанет! Чтобы повысить КПД времени простоя, можно заставить код выполняться дальше, пока не придёт ответ.</p><p>Асинхронность в питоне реализована в библиотеке asyncio и ключевыми словами async и await. С её помощью во время ожидания программа не будет «висеть», а продолжит выполняться дальше, вернувшись потом в нужную точку за результатом. Выглядеть это будет примерно так:</p><p><img src="http://127.0.0.1:80/static/articles/1_asinhronnost'_ch1/2.png" /></p><p>Код будет выглядеть так:</p><div class="code"><p>import functools<br />import time<br />from time import sleep<br /><br />import aiohttp<br />import asyncio<br /><br /><br />async def first_req():<br />    async with aiohttp.ClientSession() as session:<br />        async with session.get(&quot;https://www.youtube.com&quot;) as res1:<br />            res1_text = res1<br />            return res1_text<br /><br /><br />async def second_req():<br />    async with aiohttp.ClientSession() as session:<br />        async with session.get(&quot;https://vk.com/feed&quot;) as res2:<br />            res2_text = res2.status<br />            return res2_text<br /><br /><br />async def main():<br />    x = 5<br />    y = 10<br />    y -= x<br />    tasks = []<br /><br />    tasks.append(asyncio.create_task(first_req()))<br />    tasks.append(asyncio.create_task(second_req()))<br /><br />    res = await asyncio.gather(*tasks)<br /><br />asyncio.run(main())</p></div><p>Здесь есть серьезная ошибка – запуск двух сессий, но это пока неважно.</p><p>Проверим скорость выполнения кода:</p><p>Синхронный:</p><p><img src="http://127.0.0.1:80/static/articles/1_asinhronnost'_ch1/3.png" /></p><p>Асинхронный:</p><p><img src="http://127.0.0.1:80/static/articles/1_asinhronnost'_ch1/4.png" /></p><p>Вот и профит асинхронности! А если запросов будет больше? Попробуем выполнить 6:</p><div class="code"><p>def main():<br />    x = 5<br />    y = 10<br />    y -= x<br />    res1 = requests.get(&quot;https://www.youtube.com&quot;)<br />    res2 = requests.get(&quot;https://vk.com/feed&quot;)<br />    res3 = requests.get(&quot;https://vk.com/feed&quot;)<br />    res4 = requests.get(&quot;https://vk.com/feed&quot;)<br />    res5 = requests.get(&quot;https://vk.com/feed&quot;)<br />    res6 = requests.get(&quot;https://vk.com/feed&quot;)<br /><br /><br />main()</p></div><p>Результат</p><p><img src="http://127.0.0.1:80/static/articles/1_asinhronnost'_ch1/5.png" /></p><p>*накопировал функции с запросами*</p><div class="code"><p>async def main():<br />    x = 5<br />    y = 10<br />    y -= x<br />    tasks = []<br /><br />    tasks.append(asyncio.create_task(first_req()))<br />    tasks.append(asyncio.create_task(second_req()))<br />    tasks.append(asyncio.create_task(third_req()))<br />    tasks.append(asyncio.create_task(fourth_req()))<br />    tasks.append(asyncio.create_task(fifth_req()))<br />    tasks.append(asyncio.create_task(sixth_req()))<br /><br />    res = await asyncio.gather(*tasks)<br /><br />asyncio.run(main())</p></div><p>Результат:</p><p><img src="http://127.0.0.1:80/static/articles/1_asinhronnost'_ch1/6.png" /></p><p><strong>Основные функции для работы с asyncio</strong></p><p>Чтобы покрыть большую часть задач достаточно выучить лишь фукнций</p><p>Asuncio.run() – запускает выполнение асинхронный функций</p><p>asyncio.create_task() – создает обьект, который может быть использован для работы асинхронности (задача), т.к. просто функцию запускать нельзя</p><p>asyncio.gather() – позволяет запустить сразу несколько асинхронных задач и возвращает список их результатов. Параметр return_exceptions означает, что возвращаемый список будет содержать любое исключение, вызванное задачами, вместо того места, где должно было быть значение результата задачи. </p><p>async – ключевое слово, обозначающее асинхронную функцию. Используется только при определении функции</p><p>await – ключевое слово, обозначающее , что за ним следует асинхронная функция, требующая времени ожидания на своё выполнение. В этом случае код продолжит выполняться дальше и в будущем вернётся в место вызова этой функции за результатом.</p><p>В библиотеке asyncio есть встроенные асинхронные аналоги некоторых привычных функций, например, <strong>asyncio.sleep()</strong>. Единственное их отличие в том, что они не блокируют поток, позволяя другим асинхронным функциям выполняться. Вызываются они с ключевым словом await: </p><div class="code"><p>await asyncio.sleep(1)</p></div><p> </p><p>Подробнее о внутреннем устройстве библиотеки asyncio в этой статье</p>