<p>В этой статье я отмечу несколько основных способ оптимизировать orm запросы. Сделаю 3 таблицы для этого:</p><div class="code"><p>from django.contrib.auth import get_user_model<br />from django.db import models<br /><br />UserModel = get_user_model()<br /><br /><br />class ArticleAuthorModel(models.Model):<br />    author = models.ForeignKey(UserModel, models.CASCADE)<br />    article = models.ForeignKey(&quot;ArticleModel&quot;, models.CASCADE)<br /><br /><br />class ArticleModel(models.Model):<br />    title = models.CharField(max_length=80)<br />    email = models.CharField(max_length=50)<br />    author = models.ManyToManyField(UserModel, &quot;articles&quot;, through=ArticleAuthorModel)<br /><br />    class Meta:<br />        db_table = &quot;ArticleModel&quot;<br /><br /><br />class CommentsModel(models.Model):<br />    text = models.TextField()<br />    article = models.ForeignKey(ArticleModel, models.CASCADE, &quot;comments&quot;)<br />    author = models.ForeignKey(UserModel, models.CASCADE, &quot;comments&quot;)<br /><br />    class Meta:<br />        db_table = &quot;CommentsModel&quot;</p></div><p>Не стоит забывать, что методы вроде filter()и exclude()на самом деле не запускают запрос — они настраивают queryset для запуска при его итерации. Запрос выполняется лишь при прямом обращении к данным. Т.е. в строке:</p><div class="code"><p>result = CommentsModel.objects.all()</p></div><p>Не выполняется запрос. Переменная result только хранит запрос, а не сами данные </p><p>Итак, первая заметка – использование select_related. Этот метод решает проблему N+1, добавляя inner join.</p><p>Без select_related:</p><p>!@#$<br />class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = CommentsModel.objects.all()<br />        print(result[0].author.id)<br />        print(connection.queries)<br />        return HttpResponse(200)</p><div class="code"><p>Результат </p><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/1.png" /></p><p>Вывод: 2 запроса. Один для получения данных из указанной модели и один для получения данных из связанной модели. Можно изменить код так, чтобы получить все комментарии:</p></div><p>class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = CommentsModel.objects.all()<br />        for res in result:<br />            print(res.author.id)<br />        print(connection.queries)<br />        return HttpResponse(200)</p><div class="code"><p>Результат</p><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/2.png" /></p><p>Вывод: один запрос для получения всех комментариев, который вернул 3 записи, и еще 3 запроса для получения автора каждого комментария. Таким темпом, если надо будет получить 1000 записей, то выполнится еще 1000 запросов. Это и есть проблема N+1. Добавляю в запрос select_related:</p></div><p>class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = CommentsModel.objects.select_related(&quot;author&quot;).all()<br />        print(result[0].author.id)<br />        print(connection.queries)<br />        return HttpResponse(200)</p><div class="code"><p>Результат:</p><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/3.png" /></p><p>Теперь для все данные получаются в одном запросе через inner join</p><p>Если добавить в изначальный запрос еще инфу о статье:</p></div><p>class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = CommentsModel.objects.all()<br />        for res in result:<br />            print(res.author.id)<br />            print(res.article.id)<br />        print(connection.queries)<br />        return HttpResponse(200)</p><div class="code"><p>то на выхлопе получим 7 запросов</p><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/4.png" /></p><p>Для такого случая в related_related можно указывать несколько таблиц:</p><p>!@#$<br />class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = CommentsModel.objects.select_related(&quot;author&quot;, &quot;article&quot;).select_related().all()<br />        for res in result:<br />            print(res.author.id)<br />            print(res.article.id)<br />        print(connection.queries)<br />        return HttpResponse(200)</p></div><p>и получаем 1 запрос с двумя inner join:</p><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/5.png" /></p><p>related_related можно использовать при запросах ForeignKey, OneToOne.</p><p>При запросах ManyToMany или обратных ForeignKey следует использовать prefetch_related.</p><p>Без него:</p><div class="code"><p>class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = ArticleModel.objects.all()<br />        for res in result:<br />            print(res.author.all())<br />        print(connection.queries)<br />        return HttpResponse(200)</p></div><p>Результат:</p><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/6.png" /></p><p>С использованием prefetch_related:</p><div class="code"><p>class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = ArticleModel.objects.all()<br />        for res in result:<br />            print(res.author.all())<br />        print(connection.queries)<br />        return HttpResponse(200)</p></div><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/7.png" /></p><p>Запросов стало 2, а не 1. Дело в том, что prefetch_related не использует под капотом inner join. Он делает столько запросов в БД, сколько таблиц задействовано – в каждую отдельно и на уровне самого питона уже объединит данные­</p><p>Для большего контроля можно использовать объект Prefetch:</p><div class="code"><p>class MyView(View):</p><p>     def get(self, request, *args, **kwargs):</p><p>        result = ArticleModel.objects.prefetch_related(</p><p>            Prefetch(&quot;author&quot;, queryset=UserModel.objects.order_by(&quot;-date_joined&quot;))</p><p>        ).all()</p><p>        for res in result:</p><p>            print(res.author.all())</p><p>        print(connection.queries)</p><p>        return HttpResponse(200)</p></div><p>В этом запросе записи из связанной модели отсортированы по дате. По сути сюда можно подсунуть любой запрос: annotate, aggregate или еще один prefetch_related даже, чтобы связать таблицы на большем уровни вложенности.</p><p>Не в каждом запросе будут требовать все поля данных. Поэтому, можно использовать метод only():</p><div class="code"><p>class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = UserModel.objects.only(&quot;id&quot;, &quot;username&quot;)<br />        for res in result:<br />            print(res)<br />        print(connection.queries)<br />        return HttpResponse(200)</p></div><p>Результат:</p><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/8.png" /></p><p>Если запрос возвращает много записей, то можно брать их частями, использую принцип пагинации:</p><div class="code"><p>class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        result = CommentsModel.objects.all()[0:1]<br />        for res in result:<br />            print(res)<br />        print(connection.queries)<br />        return HttpResponse(200)</p></div><p>Результат:</p><p><img src="http://127.0.0.1:80/static/articles/6_Optimizatsija_Dajngo_ORM/9.png" /></p><p>Вместо трёх объектов запрос вернул 1, как и было указано. В запросе можно указать параметры запроса, передавая какая страница пагинации была запрошена:</p><div class="code"><p><a href="http://127.0.0.1:8080/test/comments?offset=2&amp;limit=3">http://127.0.0.1:8080/test/comments?offset=2&amp;limit=3</a></p></div><p>вью:</p><div class="code"><p>class MyView(View):<br /><br />     def get(self, request, *args, **kwargs):<br />        offset = int((request.GET.get(&quot;offset&quot;)))<br />        limit = int((request.GET.get(&quot;limit&quot;)))<br /><br />        result = CommentsModel.objects.all()[offset:offset+limit]<br />        for res in result:<br />            print(res)<br />        print(connection.queries)<br />        return HttpResponse(200)</p></div><p>Это самые базовые действия для оптимизации запросов. Помимо них можно назвать кеширование, индексацию и </p>