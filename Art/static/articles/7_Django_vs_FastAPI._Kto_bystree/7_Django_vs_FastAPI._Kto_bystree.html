<p>В прошлых статьях я сопоставил синхронные и асинхронные версии Django и FastAPI. Тут я лишь возьму лучшие показатели, уберу у Django мидлвары и еще раз запущу приложения на трёх воркерах.</p><p>Напомню, что для замеров я использую веб-сервис Artillery со следующим конфигом:</p><div class="code"><p>config:</p><p>  target: 'http://127.0.0.1:80'</p><p>  phases:</p><p>    - duration: 60</p><p>      arrivalRate: 1</p><p>      rampTo: 200</p><p>  plugins:</p><p>    ensure: {}</p><p>    apdex: {}</p><p>    metrics-by-endpoint: {}</p><p>  apdex:</p><p>    threshold: 100</p><p>scenarios:</p><p>  - flow:</p><p>      - loop:</p><p>          - get:</p><p>              url: '/async_get_all_comments'</p><p>        count: 1</p></div><p>для FastAPI и </p><div class="code"><p>config:</p><p>  target: 'http://127.0.0.1:8080'</p><p>  phases:</p><p>    - duration: 60</p><p>      arrivalRate: 1</p><p>      rampTo: 200</p><p>  plugins:</p><p>    ensure: {}</p><p>    apdex: {}</p><p>    metrics-by-endpoint: {}</p><p>  apdex:</p><p>    threshold: 100</p><p>scenarios:</p><p>  - flow:</p><p>      - loop:</p><p>          - get:</p><p>              url: '/test/sync_get_all_comments'</p><p>        count: 1</p></div><p>для Django</p><p>Обращу внимание на параметр <strong>rampTo</strong>, равным 200. В прошлых тестах он был 120. Просто я заранее знаю, что 3 воркера легко справятся с 120 запросами, поэтому решил повысить нагрузку.</p><p>Начнём с прошлого призёра. Конфиг FastAPI тот же:</p><p>Файл <strong>models </strong>с моделями:</p><div class="code"><p>from sqlalchemy import Integer, String, ForeignKey<br />from sqlalchemy.orm import Mapped, mapped_column, relationship<br />from database import Base<br /><br /><br />class UserModel(Base):<br />    __tablename__ = &quot;user&quot;<br /><br />    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)<br />    username: Mapped[str] = mapped_column(String, unique=True)  # добавлен unique=True для уникальности<br /><br />    # Define relationship if needed<br />    comments: Mapped[list[&quot;CommentsModel&quot;]] = relationship(&quot;CommentsModel&quot;, back_populates=&quot;author&quot;)<br /><br /><br />class ArticleModel(Base):<br />    __tablename__ = 'article'<br /><br />    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)<br />    title: Mapped[str] = mapped_column(String, unique=True)  # добавлен unique=True для уникальности<br /><br />    # Define relationship if needed<br />    comments: Mapped[list[&quot;CommentsModel&quot;]] = relationship(&quot;CommentsModel&quot;, back_populates=&quot;article&quot;)<br /><br /><br />class CommentsModel(Base):<br />    __tablename__ = 'comment'<br /><br />    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)<br />    text: Mapped[str] = mapped_column(String)<br />    author_id: Mapped[int] = mapped_column(ForeignKey(&quot;user.id&quot;))<br />    article_id: Mapped[int] = mapped_column(ForeignKey(&quot;article.id&quot;))<br /><br />    # Define relationships<br />    author: Mapped[&quot;UserModel&quot;] = relationship(&quot;UserModel&quot;, back_populates=&quot;comments&quot;)<br />    article: Mapped[&quot;ArticleModel&quot;] = relationship(&quot;ArticleModel&quot;, back_populates=&quot;comments&quot;)</p></div><p>Файл <strong>database</strong>:</p><p>!@#$<br />from sqlalchemy.orm import DeclarativeBase<br />from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncAttrs<br /><br /><br />SQLALCHEMY_DATABASE_URL = &quot;postgresql+asyncpg://admin:admin@db:5432/admin&quot;<br />engine = create_async_engine(<br />    SQLALCHEMY_DATABASE_URL<br />), expire_on_commit=False)<br /><br /><br />class Base(AsyncAttrs, DeclarativeBase):<br />    pass</p><div class="code"><p>Файл <strong>dependencies.py</strong> с зависимостями:</p></div><p>from database import async_session<br /><br /><br />async def get_db():<br />    async with async_session() as session:<br />        yield session</p><div class="code"><p>Вьюха:</p></div><p>@app.get(&quot;/async_get_all_comments&quot;)<br />async def async_get_all_comments(db: AsyncSession = Depends(get_db)):<br />    result = await db.execute(<br />        select(CommentsModel)<br />        .filter(<br />            CommentsModel.id &lt; 100<br />        )<br />    )<br />    return result.scalars().all()</p><div class="code"><p>Запускать приложения я буду в докере с PostgreSQL в качестве БД. Dockerfile выглядит следующим образом:</p></div><p>FROM python:3.12<br /><br />WORKDIR /code<br /><br />COPY ./requirements.txt /code/requirements.txt<br /><br />RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt<br /><br />COPY . /code</p><div class="code"><p>Файл docker-compose.yaml выглядит так:</p></div><p>version: &quot;3.0&quot;<br /><br />services:<br />  back:<br />    build: .<br />    container_name: &quot;backend&quot;<br />    ports:<br />     - &quot;80:80&quot;<br />    restart: unless-stopped<br />    command: sh -c &quot;gunicorn -w 3 -k uvicorn.workers.UvicornWorker main:app --bind 0.0.0.0:80&quot;<em><br /><br />  </em>db:<br />    image: postgres:16.3-alpine3.20<br />    container_name: db<br />    environment:<br />      POSTGRES_USER: admin<br />      POSTGRES_PASSWORD: admin<br />      POSTGRES_DB: admin<br />    volumes:<br />      - db_data:/var/lib/postgresql/data<br />    ports:<br />      - &quot;5432:5432&quot;<br />    restart: unless-stopped<br />    depends_on:<br />      - back<br />volumes:<br />  db_data:</p><div class="code"><p>В этот раз запущу gunicorn с тремя воркерами</p><p>Команда для запуска тестов:</p></div><p>artillery run --name async_fastapi_3_worker C:\Users\na2ar\Desktop\asciiart-load-test.yml --record --key &lt;сюда вставить свой ключ&gt;</p><div class="code"><p>Результат:</p><p><img src="http://127.0.0.1:80/static/articles/7_Django_vs_FastAPI._Kto_bystree/1.png" /></p><p>Асинхронный FastAPI с 3 воркерами выполнил практически все запросы без ошибок. Лишь на пике при 191 запросе в секунду произошло несколько ошибок. </p><p>Запустим лучший конфиг Django из статьи по сравнению синхрона против асинхрона: - синхронный Django. В той статье я предположил, что синхронные вьюхи слишком быстро принимают запросы, что БД, не имея ПО, которое обеспечивало бы асинхронную или какую-либо другую параллельную работу, просто крашится из-за количества подключений. Напомню, что тогда в логах начали появляться следующие ошибки:</p><p><img src="http://127.0.0.1:80/static/articles/7_Django_vs_FastAPI._Kto_bystree/2.png" /></p><p>Это произошло при использовании адаптера psycopg3, имеющего по заявлению разработчиков поддержку асинхронной работы. Как и в прошлый раз, не исключаю возможность того, что я просто что-то неправильно подключил :)</p><p>И так, код вьюхи:</p></div><p>class SyncCommentsView(View):<br />    <br />     def get(self, request, *args, **kwargs):<br />        cr = services.get_all_comments()<br />        response_data = [{'id': comment.id, 'title': comment.text} for comment in cr]<br />        return JsonResponse(response_data, safe=False)</p><div class="code"><p>метод <strong>get_all_comments() </strong>из файла services:</p></div><p>def get_all_comments():<br />    return CommentsModel.objects.filter(id__lte=100)</p><div class="code"><p>Мидлвары в файле <strong>Settings.py </strong>выглядят так:</p><p><img src="http://127.0.0.1:80/static/articles/7_Django_vs_FastAPI._Kto_bystree/3.png" /></p><p>Оставшиеся 2 мидлвара отключить не получалось, даже закомментировав практически весь файл</p><p>Это позволит хоть немного уравнять силы Django перед FastAPI</p><p>В файле <strong>docker-compose.yaml </strong>в сервис бека<strong> </strong>ввел<strong>:</strong></p></div><p>command: sh -c &quot;python manage.py makemigrations &amp;&amp;<br />                python manage.py migrate &amp;&amp;<br />                gunicorn -w 3 config.wsgi:application --bind 0.0.0.0:8080&quot;</p><div class="code"><p>Так я запущу 3 воркера, используя спецификацию wsgi. Обращу внимание, что я не указал в качестве воркера класс ювикорна. Это сделано из-за того, что wsgi не может работать с асинхронными воркерами. Такая же команда запустит дефолтные синхронные воркеры гуникорна</p><p>Запускаю тест. </p></div><p>artillery run --name sync_django_3_worker C:\Users\na2ar\Desktop\asciiart-load-test.yml --record --key a9_aFHDUaLZgOtZsTFxB1sP6yf5fiOWxgp0</p><div class="code"><p>Результат:</p><p><img src="http://127.0.0.1:80/static/articles/7_Django_vs_FastAPI._Kto_bystree/4.png" /></p><p>Что ж, Django смог успешно достичь обработки 119 запросов в секунду до того, как начал сыпать ошибки. Момент повышения индикатора vusers.failed можно считать конечной точкой, т.к. в этом месте некоторые запросы начинают возвращаться с ошибкой</p><p>Сравнивая с FastAPI:</p><p>Максимальный RPS Django: 119 req/s</p><p>Максимальный RPS FastAPI: 161 req/s</p><p>Среднее время ответа 95% ответов Django на пике нагрузки: 9.4 сек</p><p>Среднее время ответа 95% ответов FastAPI на пике нагрузки: 4.1 сек</p><p>Количество ошибок ETIMEDOUT (Слишком долгое время ожидания ответа от сервера) на пике нагрузки Django (спойлер: 100%):</p><p><img src="http://127.0.0.1:80/static/articles/7_Django_vs_FastAPI._Kto_bystree/5.png" /></p><p>Количество ошибок ETIMEDOUT (Слишком долгое время ожидания ответа от сервера) на пике нагрузки FastAPI:</p><p><img src="http://127.0.0.1:80/static/articles/7_Django_vs_FastAPI._Kto_bystree/6.png" /></p>